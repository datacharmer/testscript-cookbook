# Automatic tool build without external commands.

**One of the most important recipes. It should be in the advanced section, but very little works without this one.**

One of the main benefits of `testscript` is that it allows you to run the tool you are developing without need for a previous build phase.

If you were testing the tool in a shell, you would use this workflow:

1. build the tool, possibly using a shell script or a Makefile directive
2. invoke the tool from your tests, and check the results.

In this scenario, if you forget to build the tool, or your pre-test-run script is faulty, you may run your tests on a stale binary, and your latest changes risk of remaining untested.

This recipe needs two components:

* One or more `TestSomething` function that will invoke `testscript.Run` to test your tool;
* A `TestMain` where you will invoke `testscript.RunAll`, which allows you to define a name for the tool to be tested.
* The main function of your application not running operations directly, but using a separate function that returns an integer.

Here's an example using a sample tool that was built to set examples for a recent presentation on `testscript` ([wordcount](https://github.com/datacharmer/wordcount/tree/main)).


```go
// main_test.go
package main

import (
	"testing"

	"github.com/rogpeppe/go-internal/testscript"
)

func TestWordCount(t *testing.T) {
	testscript.Run(t, testscript.Params{
		Dir:                 "testdata/wordcount",
		RequireExplicitExec: true,
	})
}

func TestMain(m *testing.M) {
	exitCode := testscript.RunMain(m, map[string]func() int{
		"wordcount": cmd.RunMain,
	})
	os.Exit(exitCode)
}

```

```go
// main.go
package main

import (
	"os"

	"github.com/datacharmer/wordcount/cmd"
)

func main() {
	os.Exit(cmd.RunMain())
}
```

The [function `runMain()`](https://github.com/datacharmer/wordcount/blob/main/cmd/wordcount.go#L26,L53) is where the real action happens.

What happens in this code is that we are creating a `wordcount` alias that is assigned to the function that the real tool `main` would call. This ensures that when we invoke `wordcount` within the test scripts, we are using the latest code, which has been compiled on-the-fly when we run `go test`.

Notes:

1. The binary being created for testing is the one generated by `go test`, which would be otherwise be called `yourPackageName.test`. There is no separate binary, which is convenient for speed, but it may have side effects.
2. One of the possible side effects of having the tool binary and the test binary together is that if you want to test `toolname -h`, you are running the test usage of `go test`, which might or might not include the output of your tool. For this reason, using a separate command line manager such as `Cobra` will help you keeping your tool commands and options safe.
3. If you need to run preparations before all tests, make sure that there is no writing to standard output during that phase, as all your tests will fail due to such text. Also, make sure the preparation function can detect whether the preparation has already run, and skip if it has. The following point will explain the reason.
4. Be aware that the `TestMain` function will get called every time your tool is invoked within the test scripts. This is counter intuitive, but it's a direct consequence of using the testing binary as tool binary.